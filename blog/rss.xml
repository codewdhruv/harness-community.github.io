<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Harness ❤️ Open Source Blog</title>
        <link>https://harness-community.github.io/blog</link>
        <description>Harness ❤️ Open Source Blog</description>
        <lastBuildDate>Wed, 05 Oct 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Harness CI - Background Step]]></title>
            <link>https://harness-community.github.io/blog/harness-ci-background-step</link>
            <guid>harness-ci-background-step</guid>
            <pubDate>Wed, 05 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Introduction]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">​</a></h2><p>Background steps are useful for running services that need to run for the entire lifetime of a build. This can be used when user wants to run something in background throughout the stage execution or when you want to run an end to end test, redis service or mysql local service to run some operations  </p><p><img loading="lazy" alt="Background Step Introduction" src="/assets/images/background_step_introduction-19ceae8378b8b5798e151431bd29f020.png" width="1446" height="389" class="img_ev3q"></p><p>Before diving deep into background step further, let’s talk about service dependencies, how it helped and what were the shortcomings that service dependencies had that we have to introduce the background step </p><p><strong>Service Dependency</strong> is a detached service that's accessible to all steps in a stage. Service dependencies support workflows such as</p><ul><li><strong>Integration testing:</strong> You can set up a service and then run tests against this service.</li><li><strong>Running Docker-in-Docker:</strong> You can set up a dind service to process Docker commands in Run Steps.</li></ul><p>Well you can see how important it was to introduce service dependency in your pipeline but then why did we introduce the background step?</p><p>Well service dependency did have some shortcomings which background step could solve easily for example:</p><ol><li><p>Suppose you want to run a cypress server which needs some custom commands to start, you won’t be able to do that with a service dependency but with a background step as it accepts commands so with the help of that you can write a script and run any service.</p></li><li><p>Suppose you want redis,postgres and node js server to run together,with the help of service dependency you will have to define it separately but with the background step you can easily do that by adding a docker compose file ( the docker file either needs to be downloaded or we can easily use the one present in the git repo) and then doing docker-compose up with the help of command functionality. </p></li></ol><p><img loading="lazy" alt="Background Step Pipeline" src="/assets/images/background_step_pipeline-123ee78afe95a2e89c2277a3fbee8424.png" width="1268" height="552" class="img_ev3q"></p><p>We discussed about some of the shortcomings of service dependency that background step could solve, let’s have a detailed look on three of the major differences between the two:</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="background-step-support-commands">Background step support commands<a class="hash-link" href="#background-step-support-commands" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="Background Step Settings" src="/assets/images/background_step_settings-f2e9f10bf2a34dce91de075032e95b02.png" width="1198" height="1506" class="img_ev3q"></p><p>Let’s say you are running some local server and you want to run some pre command or you want to fetch some file before running the server , there is an optional field called command in the background step. With the support of this optional functionality it acts as a run step now .</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="background-step-can-be-added-anywhere-in-the-pipeline-execution">Background step can be added anywhere in the pipeline execution<a class="hash-link" href="#background-step-can-be-added-anywhere-in-the-pipeline-execution" title="Direct link to heading">​</a></h3><p>The background step can be added anywhere during the pipeline execution, thus making it flexible for the user.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="background-step-supports-templatization">Background step supports Templatization<a class="hash-link" href="#background-step-supports-templatization" title="Direct link to heading">​</a></h3><p>The background step supports templates that can be reused across Pipelines which enhance developer productivity,reduce onboarding time,and enforce standardization across the teams.
Also ,the background step supports sequential approvals, that is when one step is completed then only you can move to the other step,whereas service dependency was running all the commands at the same time.</p><p>To know more about templates visit <a href="https://docs.harness.io/article/6tl8zyxeol-template" target="_blank" rel="noopener noreferrer">Templates</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="some-important-points">Some important points:<a class="hash-link" href="#some-important-points" title="Direct link to heading">​</a></h4><ul><li><p>A Background step starts a service and then proceeds. For any later step that relies on the service,it is good practice to verify that the service is running before you send requests.</p></li><li><p>If the pipeline runs on a VM build infrastructure, you can run the background service directly on the VM rather than in a container.To do this, leave the Container Registry and Image fields blank.</p></li></ul>]]></content:encoded>
            <category>continuous-integration</category>
            <category>integration-test</category>
        </item>
        <item>
            <title><![CDATA[Harness CI Onboarding - Beginners Guide]]></title>
            <link>https://harness-community.github.io/blog/harness-ci-onboarding</link>
            <guid>harness-ci-onboarding</guid>
            <pubDate>Wed, 05 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Introduction]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">​</a></h2><p>This beginner guide aims to help learners learn about the basic components of Harness CI and develop an understanding of the DevOps ecosystem involved in the Software Development lifecycle. In this article we will learn about the basic features of Harness CIE and also get started by building the first basic sample pipeline.</p><p>Engineering team is usually expected to deliver error-free code at high frequency. A fast and reliable CI/CD pipeline is a major part for implementation of that in a sustainable model over time. Harness Continuous Integration tool which is built with test intelligence, native secrets, fine-grained RBAC, and extensible governance  as one of the best solutions in the marketplace for automated pipelines. Automated pipelines remove user errors, provide feedback loops to developers and helps enable fast product iterations.</p><p><strong>What is a pipeline?</strong></p><p>A Pipeline is an end-to-end process that delivers a new version of your software. It can be considered to be a cyclical process that includes integration, delivery, operations, testing, deployment, real-time updates, and metrics monitoring.</p><p>For example: A pipeline can use the CI module of Harness to build, test &amp; push code and then also a CD module to deploy the artifact to the production environment.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="prerequisites">Prerequisites<a class="hash-link" href="#prerequisites" title="Direct link to heading">​</a></h3><ul><li>Github Account (<a href="https://docs.harness.io/article/kqik8km5eb-source-code-manager-settings#source-code-manager-settings" target="_blank" rel="noopener noreferrer">Check out the other source code managers here</a>)</li><li>Docker Hub Account &amp; Repository (<a href="https://docs.harness.io/article/66ykcm0sf0-build-and-push-to-gcr-step-settings" target="_blank" rel="noopener noreferrer">Other artifactory packages</a>)</li><li>Installation of K8s Delegate for Harness Delegate</li><li>About Harness CI</li><li>Features in Harness CI</li><li>Getting Started with your first pipeline</li><li>Troubleshooting frequently encountered issues</li><li>Conclusion: Developer Feedback on Harness CIE</li><li>What’s Next?</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="environment">Environment<a class="hash-link" href="#environment" title="Direct link to heading">​</a></h3><ul><li>Ubuntu 20.04/22.04</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="requirements">Requirements<a class="hash-link" href="#requirements" title="Direct link to heading">​</a></h3><ul><li>Kubernetes cluster for Harness Delegate and build farm.</li><li>You'll need a Kubernetes cluster for Harness to use for the Harness Delegate and as a build farm. Ensure you have a cluster that meets the following requirements:</li><li>Number of pods: 3 (two pods for the Harness Delegate, the remaining pod for the build farm).</li><li>Machine type: <code>4vCPU</code></li><li>Memory: 16GB RAM. The build farm and Delegate requirements are low but the remaining memory is for Kubernetes, the Docker container, and other default services.</li><li>Networking: Outbound <code>HTTPS</code> for the Harness connection, and to connect to Docker Hub. Allow TCP port 22 for SSH.</li><li>Namespace: When you install the <code>Harness Delegate</code>, it will create the <code>harness-delegate</code> namespace. You'll use the same namespace for the build farm.</li></ul><p>A <strong>Kubernetes service account</strong> with permission to create entities in the target namespace is required. The set of permissions should include <code>list</code>, <code>get</code>, <code>create</code>, and <code>delete</code> permissions. In general, the cluster-admin permission or namespace admin permission is enough.
For more information see <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles" target="_blank" rel="noopener noreferrer">User-Facing Roles</a> from Kubernetes.</p><p>This tutorial implements creation of a pipeline over a github repository thus you’ll be required to create a github account &amp; host a project over a repository. To create a new repository on github follow these steps:</p><ol><li>Move to the upper-right corner on the github webapp &amp; use the  drop-down menu to select New repository option.</li></ol><p><img loading="lazy" alt="create-new-repository" src="/assets/images/repo-create-ba4bc7a2ad541270d85b12a1b30d61da.png" width="192" height="201" class="img_ev3q"></p><ol start="2"><li>Type the name of the repository. The repository name is unique &amp; cannot be same as already hosted repo names.</li></ol><p><img loading="lazy" alt="repo-name" src="/assets/images/create-repository-desc-d047c18e7b4c9821faa90fdc826b9dd4.png" width="808" height="335" class="img_ev3q"></p><ol start="3"><li>Select the repository visibility &amp; click on create repository.</li></ol><p><img loading="lazy" alt="repo-public" src="/assets/images/create-repository-public-private-aa8d0703e0ada95178c150a84eb7b64e.png" width="750" height="302" class="img_ev3q"></p><p><img loading="lazy" alt="create-repo" src="/assets/images/repo-create-ba4bc7a2ad541270d85b12a1b30d61da.png" width="192" height="201" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="installing-docker-engine">Installing Docker Engine<a class="hash-link" href="#installing-docker-engine" title="Direct link to heading">​</a></h3><p>To get started with Docker Engine make sure you meet the <a href="https://docs.docker.com/engine/install/ubuntu/#prerequisites" target="_blank" rel="noopener noreferrer">prerequisites</a> then install Docker. Older versions of Docker were called <code>docker</code>, <code>docker.io</code>, or <code>docker-engine</code>. If these are installed uninstall them with this command.</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">sudo</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">apt-get</span><span class="token plain"> remove </span><span class="token function" style="color:#d73a49">docker</span><span class="token plain"> docker-engine docker.io containerd runc</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong><a href="https://docs.docker.com/engine/install/" target="_blank" rel="noopener noreferrer">Check out this documentation to get your Docker Engine installed</a></strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="installation-of-k8s-delegate-for-harness-delegate">Installation of K8s Delegate for Harness Delegate<a class="hash-link" href="#installation-of-k8s-delegate-for-harness-delegate" title="Direct link to heading">​</a></h3><p>Harness Delegate is the service that connects all the components of the pipeline i.e artifact, infrastructure, collaboration, verification and other providers with the Harness Manager. It performs all the operations in the deployment lifecycle. Here we’ll install Kubernetes Delegate.</p><ol><li>Move to the Harness Platform, in the Manager section click on setup and select Delegates.</li><li>In the delegates tab, click on the install delegate option with preference to Kubernetes YAML as the download type.</li><li>Update the name and profile and download the K8s Delegate or copy the download link.</li><li>Navigate to the harness-delegate-kubernetes folder that you extracted in the terminal using the following command</li></ol><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">tar</span><span class="token plain"> -zxvf harness-delegate-kubernetes.tar.gz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token builtin class-name">cd</span><span class="token plain"> harness-delegate-kubernetes</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>With this you will directly connect with your cluster from the terminal and thus can easily copy the YAML file over.</p><ol start="5"><li>To verify the connection of your created K8s Delegate with the Harness Platform use the following command</li></ol><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">wget</span><span class="token plain"> -p https://app.harness.io/ -O /dev/null</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="6"><li>Now we’ll install the harness delegate using the <code>harness-delegate.yaml</code> file using this command</li></ol><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">kubectl apply -f harness-delegate.yaml</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="7"><li>To verify that the delegate pod was created run the following command.</li></ol><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">kubectl get pods -n harness-delegate</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>With this now you're ready to connect Harness to your artifact servers, clusters, and so on.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="about-harness-ci">About Harness CI<a class="hash-link" href="#about-harness-ci" title="Direct link to heading">​</a></h3><p>Harness CI is powered by Drone the most popular open source CI tool. It’s built for speed and developer experience. Onboarding it is simple and this is what this guide is about.</p><p>Harness alongside the open source counterpart Drone introduced new features to scale the developer onboarding experience and reduce the time involved in the process drastically as compared to the industry standards.</p><p><strong>Harness CI’s major features are the following:</strong></p><ol><li>Containerized Steps (Zero Dependencies)</li><li>Visual Pipeline Builder with YAML Config as Code</li><li>Git Operations, Secrets &amp; Fine grained RBAC for security etc</li><li>Test Intelligence</li><li>Integrated Platform</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="getting-started-with-your-first-pipeline">Getting Started with your first pipeline<a class="hash-link" href="#getting-started-with-your-first-pipeline" title="Direct link to heading">​</a></h3><p>Pipelines are a group of one or more stages. They are responsible for managing and automating builds, testing, deployments, and other important build and release stages.</p><p>To create a new Pipeline in Harness CI follow the steps below:</p><ol><li>Move to the Harness Platform, click on projects. Create a new project incase you haven’t already created one.</li><li>Move to the modules section and click on Continuous Integration &amp; click on create a new pipeline.</li><li>Enter the name for the pipeline &amp; click on start. It usually takes 2-4 min for the provisioning stage of the pipeline.</li></ol><iframe width="640" height="480" src="https://www.youtube.com/embed/251WU_OG0BI" frameborder="0" allow="autoplay; encrypted-media"></iframe><p>The backbone of the pipeline is the build stage. This is where the user specifies the pipeline configuration details as the codebase to build, the infrastructure, the build workflow and all other additional components. The next step involves establishing the connection of the pipeline with the external resource. We use a <code>connector</code> in Harness CIE to develop this pipeline connection. The <code>connector</code> is a configurable object that automatically establishes connection to an external resource. </p><p>To create the Build Stage follow the steps given below: </p><ol><li><p>Move to the newly created pipeline in the Pipeline Studio, add a stage &amp; select build.</p></li><li><p>Add a stage name &amp; under the configure codebase select connect connector.</p></li><li><p>Click on New Creator &amp; give preference to Github Connector from all the available options for connector type. </p></li></ol><p>To configure the connector successfully provide the following details i.e
a. URL Type as a Repository
b. Connection Type as HTTP
c. GitHub Repository URL</p><p>You’ll also have to verify the github username &amp; PAT’s to make use of the connector. These secrets are stored in the Harness Secret Manager. </p><ol start="4"><li><p>Once the connector has been configured with the necessary credentials select Enable API Access.</p></li><li><p>The connectivity medium can be directly through Harness Platform or through an delegate service running in an external resource. </p></li><li><p>In this guide we’ll install the delegate into the K8s cluster. Select Connect Through An Harness Delegate from the available options.</p></li><li><p>Install the new delegate with infrastructure type as Kubernetes.</p></li><li><p>Configure the delegate information as Name, Size, Permissions etc &amp; install the delegate using the workspace definition YAML file that can be installed directly to the build infrastructure.</p></li><li><p>Download the YAML script and run it on the previously created cluster from the terminal.</p></li><li><p>Login to the K8s cluster from the same terminal and click on connect option.</p></li><li><p>Install the Harness Delegate using the <code>harness-delegate.yaml</code> file using the following command.</p></li></ol><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl apply -f harness-delegate.yaml</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="12"><li><p>Set up the Delegate with the necessary configuration from the Delegate Setup option.</p></li><li><p>Once the delegate is setup successfully you’ll see the connector &amp; repo details in the About your stage component.</p></li><li><p>Select on setup stage and the new stage will be added to the pipeline.</p></li></ol><p>The next step is to set up &amp; define the Build Farm Infrastructure under the pipeline configuration settings. To setup the BFI follow the steps below:</p><ol><li>Select the newly created K8s cluster &amp; create a new connector. Specify details as Name, Details, Delegates Setup &amp; Connection Test.</li><li>Once verified click on Finish to add the new connector to the K8s Cluster Field.</li><li>Verify the namespace carefully and move to the Execution component of the pipeline.</li></ol><p>Now we can build &amp; run tests over &amp; against the hosted code. Move to the Execution Tab of the pipeline &amp; add the step to run the steps. Follow the following steps to setup the Execution workflow of the pipeline:</p><ol><li><p>Add a run step to the pipeline &amp; configure it as follows: </p><ul><li>Give the step an appropriate name</li><li>Click on add a new connector option under the container registry option.</li><li>Select the connector type as Docker Registry</li></ul></li><li><p>We’ll now create a new connector to the DockerHub account. Specify the account credentials and configure the secrets.</p></li></ol><p><img loading="lazy" alt="docker-img" src="/assets/images/ci-tut-04-docker-connector-02-details-694e13ae74e3e5c8cb93f30da56c6471.png" width="583" height="437" class="img_ev3q"></p><ol start="3"><li>Verify the connection test &amp; once successful click on Finish. Now we can Configure Run Step pane, with the new Connector in the Container Registry setting.
Configure the step as follows:</li></ol><ul><li>Give an appropriate step name.</li><li>The Container Registry should show the Docker Hub Connector you just created.</li><li>Image: <code>golang:1.15</code></li><li>Command:</li></ul><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">go get gotest.tools/gotestsum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">gotestsum --format</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">standard-verbose --junitfile unit-tests.xml </span><span class="token operator" style="color:#393A34">||</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">true</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token assign-left variable" style="color:#36acaa">CGO_ENABLED</span><span class="token operator" style="color:#393A34">=</span><span class="token number" style="color:#36acaa">0</span><span class="token plain"> </span><span class="token assign-left variable" style="color:#36acaa">GOOS</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">linux </span><span class="token assign-left variable" style="color:#36acaa">GOARCH</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">amd64 go build -a -tags netgo</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The last line contains the go build command to compile the package, along with its dependencies. Once configured click on Apply changes &amp; save the pipeline.</p><p>Now we can add the step to build &amp; push the created image into the DockerHub repository. A repository in DockerHub is required to receive the artifacts from the pipeline. Add a step and specify the DockerHub account credentials. </p><p>Configure the step as follows:</p><ul><li>Select Name as the Step name you defined earlier.</li><li>Select the Docker Hub Connector you set up previously.</li><li>Paste the docker repository URL &amp; specify the tags: <code>&lt;+pipeline.sequenceId&gt;</code></li><li>After successfully configuring the step components select Apply Changes &amp; save the pipeline.</li></ul><p>The pipeline is now ready for execution &amp; can be used for running tests.
You can also add the Integration Tests to the pipeline. To execute the pipeline click on Run. Select Git Branch and the git branch name when prompted such as main and click on Run Pipeline</p><p>You can view the logs of each step by clicking on it or else can also switch to the console view for more tracking down the micro details.
The entire pipeline is also available in YAML. You can directly make changes to the YAML file and save the changes and it will automatically be reflected in the pipeline when executed.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion---developer-feedback-on-harness-cie">Conclusion - Developer Feedback on Harness CIE<a class="hash-link" href="#conclusion---developer-feedback-on-harness-cie" title="Direct link to heading">​</a></h3><p>Developers spend a lot of time into coding &amp; solving the engineering problems. With Harness CIE we can now easily cut down the operational &amp; functional time cost drastically. The added advantage to the features of CIE is the User Interface of CIE which is sleek and easy
&amp; solves major issues of longer build and testing time. Harness CIE automatically scales up the build, test and deploy cycles. </p><p>The product focuses on developers &amp; is completely developer-centric built around what a developer seeks to be the one stop solution for CI/CD.</p>]]></content:encoded>
            <category>continuous-integration</category>
            <category>harness-ci</category>
            <category>beginners-guide</category>
            <category>getting-started</category>
            <category>cme</category>
        </item>
        <item>
            <title><![CDATA[Welcome]]></title>
            <link>https://harness-community.github.io/blog/welcome</link>
            <guid>welcome</guid>
            <pubDate>Sat, 01 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Hey y'all amazing users of Harness Community!]]></description>
            <content:encoded><![CDATA[<p>Hey y'all amazing users of Harness Community!</p><p>Now, it's easy to submit your blog/articles and it's just a PR away!</p><p>Simply create a PR by adding Markdown files (or folders) to the <code>blog</code> directory in <a href="https://github.com/harness-community/harness-community.github.io" target="_blank" rel="noopener noreferrer">harness-community.github.io</a> repository!</p><p>A blog post folder can be convenient to co-locate blog post images abd can be displayed like below:</p><p><img loading="lazy" alt="Harness Community" src="/assets/images/harnesser-396d47c77cd8f7af31887571607a7ed0.png" width="2560" height="801" class="img_ev3q"></p><p>Oh and the other cool thing is, you can directly embed Youtube videos to your blog post and users can watch it on the same page and of course on a new tab if they want to;)</p><iframe width="640" height="480" src="https://www.youtube.com/embed/I4sbENt4IeM" frameborder="0" allow="autoplay; encrypted-media"></iframe><p>The blog supports tags as well! so refer the list of available tags and add it to your blog post!</p><p>Stay tuned for more improvements as this site is still in development phase:)</p><p>Any contributions are welcome!</p>]]></content:encoded>
            <category>community</category>
            <category>blog</category>
            <category>newuser</category>
            <category>ompragash</category>
        </item>
    </channel>
</rss>